---
title: "Laborator 5"
subtitle: Funcția de repartiție și cuantilele empirice
output:
  pdf_document:
    includes:
      before_body: tex/body.tex
      in_header: tex/preamble.tex
    keep_tex: yes
    number_sections: yes
  html_document:
    code_folding: show
    css: labs_css/labs.css
    keep_md: yes
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
    includes:
      in_header: lab_header/lab_header.html
      after_body: lab_header/lab_footer.html
  word_document:
    fig_caption: yes
    highlight: pygments
    keep_md: yes
    reference_docx: template/template.docx
    toc: no
---

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 60
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

Obiectivul acestui laborator este de a ilustra noțiunea de funcție de repartiție empirică și de cuantile empirice și de a verifica câteva proprietăți asimptotice ale acestora. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra) # new table styles
library(latex2exp)
# library(grid)
# library(gridExtra)
# library(cowplot)
# library(gridGraphics)

knitr::opts_chunk$set(comment = NA, prompt = FALSE, collapse = TRUE, error = TRUE, fig.align = 'center')

source("functions/getOutputFormat.R")

if (getOutputFormat() == "pdf_document"){
  source("functions/figureNumber_tex.R")
  source("functions/tableNumber_tex.R")
  options(knitr.table.format = "latex") # add format latex 
  dimplot = "70%"
  dimplot2 = "80%"
  engine_block = "block"
}else{
  source("functions/figureNumber.R")
  source("functions/tableNumber.R")
  options(knitr.table.format = "html") # add format html 
  dimplot = "80%"
  dimplot2 = "90%"
  engine_block = "block2"
}

```


# Funcția de repartiție empirică 

Fie $X_1,X_2,\ldots,X_n$ un eșantion de talie $n$ dintr-o populație a cărei funcție de repartiție este $F$. Funcția de repartiție empirică este definită, pentru toate valorile $x\in\mathbb{R}$, prin 

$$
  \hat{F}_n(x) = \frac{1}{n}\sum_{i = 1}^{n}\mathbf{1}_{(-\infty, x]}(X_i) = \frac{1}{n}\sum_{i = 1}^{n}\mathbf{1}_{(-\infty, x]}(X_{(i)})
$$

unde $X_{(1)}, X_{(2)}, \ldots, X_{(n)}$ reprezintă statisticile de ordine. Observăm că, notând $X_{(n+1)} = +\infty$, avem

$$
  \hat{F}_n(x) = \sum_{i = 1}^{n}\frac{i}{n}\mathbf{1}_{\left[X_{(i)}, X_{(i+1)}\right)}(x).
$$

```{r, type = "rmdexercise", engine = engine_block}
Dacă $\hat{F}_n(x)$ este funcția de repartiție empirică asociată unui eșantion de talie $n$, dintr-o populație a cărei funcție de repartiție este $F$, atunci, pentru $x\in\mathbb{R}$:
  
  - variabila aleatoare $n\hat{F}_n(x)$ este repartizată binomial $\mathcal{B}(n, F(x))$
  - are loc convergența (LNM): $\hat{F}_n(x)\overset{a.s.}{\to} F(x)$
  - are loc proprietatea de normalitate asimptotică (TLC): $\sqrt{n}(\hat{F}_n(x) - F(x))\overset{d}{\to}\mathcal{N}(0,F(x)(1-F(x)))$. 
  
Ilustrați grafic rezultatele de mai sus pentru o populație repartizată $\mathcal{N}(0,1)$ și respectiv $\mathcal{E}(3)$. Pentru proprietatea de normalitate considerați $x_0 = 2$ și respectiv $x_0 = 1.5$. 


```

Fie $x\in\mathbb{R}$ fixat și definim variabilele aleatoare $Y_i = \mathbf{1}_{(-\infty, x]}(X_i)$, $1\leq i\leq n$. Cum $X_1,X_2,\ldots,X_n$ sunt i.i.d. deducem că $Y_1,Y_2,\ldots,Y_n$ sunt i.i.d. și în plus $Y_i\sim \mathcal{B}(p)$ cu $p = \mathbb{P}(Y_1 = 1) = F(x)$.

Din definiția funcției de repartiție empirică avem 

$$
  \hat{F}_n(x) = \frac{1}{n}\sum_{i = 1}^{n}\mathbf{1}_{(-\infty, x]}(X_i) = \frac{1}{n}\sum_{i = 1}^{n}Y_i
$$

și aplicând *Legea Tare a Numerelor Mari* obținem

$$
  \hat{F}_n(x) = \frac{1}{n}\sum_{i = 1}^{n}Y_i \overset{a.s.}{\underset{n\to\infty}\longrightarrow} \mathbb{E}[Y_1] = F(x).
$$

În mod similar aplicând *Teorema Limită Centrală* deducem 

$$
  \sqrt{n}(\hat{F}_n(x) - F(x))\overset{d}{\underset{n\to\infty}\longrightarrow}\mathcal{N}(0,Var(Y_1)) = \mathcal{N}(0,F(x)(1-F(x))).
$$

Pentru ilustrare, în cazul $\mathcal{N}(0,1)$ avem convergența

```{r, echo=FALSE, out.width = dimplot}
n = 150 
x = rnorm(n)

plot(sort(x), (1:n)/n, type = "s", 
     main = "N(0,1)", bty = "n", 
     col = "grey80",
     xlab = "x", 
     ylab = expression(hat(F)[n](x)))
points(sort(x), (1:n)/n, pch = 16,
       col = "royalblue")
lines(seq(-3,3,0.01), pnorm(seq(-3,3,0.01)),
      col = "brown3", lwd = 2, lty = 2)

```

și proprietatea de normalitate (TLC)

```{r, echo=FALSE, out.width = dimplot, warning=FALSE}
S = 10000
n = 1250
x0 = 2
sigma_sq = pnorm(x0)*(1-pnorm(x0))
sigma = sqrt(sigma_sq)
Fx0 = pnorm(x0)

Fn = numeric(S) 

for (i in 1:S){
  x = rnorm(n)
  Fn[i] = (sum(x<=x0)/n - Fx0)*sqrt(n)/sigma
}

# plot

par(fig = c(0, 1, 0, 0.45))
boxplot(Fn, horizontal=T, bty="n", xlab=expression(sqrt(n) (hat(F)[n] (2) - F(2))/sqrt(F(2)(1-F(2)))),
        col = "grey80",
        ylim = c(-3, 3), 
        cex = 0.7)

par(fig = c(0, 1, 0.25, 1), new = T)
hist(Fn, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-4, 4),
     col = "grey80",
     main = "TLC pentru functia de repartitie empirica - N(0,1)",
     xlab = "",
     ylab = "Densitatea")

lines(seq(-4, 4, length.out = 250),
      dnorm(seq(-4, 4, length.out = 250)), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(Fn)
```

Pentru repartiția $\mathcal{E}(3)$ avem  

```{r, echo=FALSE, out.width = dimplot}
n = 250 
x = rexp(n, 3)

plot(sort(x), (1:n)/n, type = "s", 
     main = "E(3)", bty = "n", 
     col = "grey80",
     xlab = "x", 
     ylab = expression(hat(F)[n](x)))
points(sort(x), (1:n)/n, pch = 16,
       col = "royalblue")
lines(seq(0,3,0.01), pexp(seq(0,3,0.01), 3),
      col = "brown3", lwd = 2, lty = 2)

```

și rezultatul de normalitate asimptotică

```{r, echo=FALSE, out.width = dimplot, warning=FALSE}
S = 10000
n = 2000
x0 = 1.5
lambda = 3

sigma_sq = pexp(x0, lambda)*(1-pexp(x0, lambda))
sigma = sqrt(sigma_sq)
Fx0 = pexp(x0, lambda)

Fn = numeric(S) 

for (i in 1:S){
  x = rexp(n, lambda)
  Fn[i] = (sum(x<=x0)/n - Fx0)*sqrt(n)/sigma
}

# plot

par(fig = c(0, 1, 0, 0.45))
boxplot(Fn, horizontal=T, bty="n", xlab=expression(sqrt(n) (hat(F)[n] (1.5) - F(1.5))/sqrt(F(1.5)(1-F(1.5)))),
        col = "grey80",
        ylim = c(-4, 4), 
        cex = 0.7)

par(fig = c(0, 1, 0.25, 1), new = T)
hist(Fn, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-4, 4),
     col = "grey80",
     main = "TLC pentru functia de repartitie empirica - E(3)",
     xlab = "",
     ylab = "Densitatea")

lines(seq(-4, 4, length.out = 250),
      dnorm(seq(-4, 4, length.out = 250)), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(Fn)
```

Conform rezultatului anterior putem spune că $\hat{F}_n(x)$ este un estimator *rezonabil* pentru funcția de repartiție $F(x)$ dat fiind o valoare $x\in\mathbb{R}$ fixată. Întrebarea care se pune este dacă $\hat{F}_n(x)$ este un estimator *rezonabil* pentru întreaga funcție de repartiție $F(x)$ ? Răspunsul la această întrebare este dat de *Teorema Glivenko-Cantelli*^[Pentru o demonstrație a acestei teoreme se poate consulta, spre exemplu, cartea lui Sidney Resnick *A probability path*, Springer, 1998 (pag 224)] de mai jos:

```{r, type = "rmdinsight", engine = engine_block}
**Teorema Glivenko-Cantelli**. Fie $(X_n)_n$ un șir de variabile aleatoare independent și identic repartizate, cu funcția de repartiție comună $F$. Atunci are loc

$$
  \sup_{x\in\mathbb{R}}\left|\hat{F}_n(x) - F(x)\right| \overset{a.s.}{\underset{n\to\infty}\longrightarrow} 0.
$$


```

# Cuantile empirice

Reamintim că dată fiind o funcție de repartiție $F$, funcția *cuantilă* (inversa generalizată) asociată lui $F$, $F^{-1}:(0,1)\to\mathbb{R}$ este definită prin 

$$
  F^{-1}(u) = \inf\{x\in\mathbb{R}\,|\,F(x)\geq u\}, \quad \forall u\in(0,1)
$$
unde folosim convențiile $\inf\mathbb{R} = -\infty$ și $\inf\emptyset = +\infty$.

```{r, type = "rmdinsight", engine = engine_block}
Funcția cuantilă $F^{-1}$ verifică următoarele proprietăți:

  1) Valoarea în $0$: $F^{-1}(0) = -\infty$
  2) Monotonie: $F^{-1}$ este crescătoare
  3) Continuitate: $F^{-1}$ este continuă la stânga
  4) Echivalență: pentru $\forall u\in[0,1]$ avem $F(x)\geq u \iff x\geq F^{-1}(u)$
  5) Inversabilitate: $\forall u\in[0,1]$ avem $(F\circ F^{-1})(u)\geq u$. În plus
    a) dacă $F$ este continuă atunci $F\circ F^{-1} = Id$ dar dacă nu este injectivă atunci există $x_0$ așa încât $(F^{-1}\circ F)(x_0)<x_0$
    b) dacă $F$ este injectivă atunci $F^{-1}\circ F = Id$ dar dacă nu este continuă atunci există $u_0$ astfel că $(F\circ F^{-1})(u_0)>u_0$


```

Pentru a exemplifica punctul 5a, putem considera variabila aleatoare $X\sim\mathcal{U}[0,1]$ a cărei funcție de repartiție $F$ este continuă dar nu injectivă și în plus $(F^{-1}\circ F)(2) = F^{-1}(1) = 1 < 2$. Pentru punctul 5b să considerăm variabilele aleatoare $Y\sim\mathcal{N}(0,1)$ și $B\sim\mathcal{B}(0.5)$ independente și să definim $X = BY$. Atunci funcția de repartiție a lui $X$ verifică $F(0-) = \frac{1}{4}$ și $F(0) = \frac{3}{4}$, este injectivă dar nu și continuă în $0$ și în plus avem $(F\circ F^{-1})(1/2) = F(0) = \frac{3}{4}>\frac{1}{2}$.

Se numește *cuantilă* de ordin $p\in(0,1)$ (sau $p$-cuantilă) asociată lui $F$ valoarea

$$
  x_p = F^{-1}(p) = \inf\{x\in\mathbb{R}\,|\,F(x)\geq p\}.
$$

Cuantila de ordin $0.5$, $x_{\frac{1}{2}}$ se numește mediana lui $F$ și se notează cu $M$ sau $Q_2$, iar cuantilele de ordin $\frac{1}{4}$ și respectiv $\frac{3}{4}$ se numesc prima și respectiv a treia cuartilă și se notează cu $Q_1$ și respectiv $Q_3$.

Fie acum $X_1,X_2,\ldots,X_n$ un eșantion de talie $n$ dintr-o populație a cărei funcție de repartiție este $F$ și fie $\hat{F}_n$ funcția de repartiție empirică asociată. Pentru $p\in(0,1)$ definim cuantila empirică de ordin $p$ și o notăm $\hat{x}_p = \hat{x}_p(n)$ valoarea

$$
  \hat{x}_p = \hat{F}_n^{-1}(p) = \inf\{x\in\mathbb{R}\,|\,\hat{F}_n(x)\geq p\}.
$$

Folosind convenția $X_{(0)}=-\infty$, cunatila empirică de ordin $p$ coincide cu una dintre statisticile de ordine:

$$
  \hat{x}_p = X_{(i)} \iff np\leq i< np+1 \iff \hat{x}_p = X_{(\lceil np \rceil)},
$$

unde $\lceil x \rceil$ reprezintă cea mai mică valoare întreagă mai mare sau egală cu $x$.

Are loc următorul rezultat^[O demonstrație a acestui rezultat care nu necesită funcții caracteristice se regăsește în articolul lui Jan Wretman *A Simple Derivation of the Asymptotic Distribution of a Sample Quantile*, Scand. J. Statist., 5(2): 123-124, 1978.]:

```{r, type = "rmdinsight", engine = engine_block}
Fie $X_1,X_2,\ldots,X_n$ un eșantion de talie $n$ dintr-o populație cu funcția de repartiție $F$, $p\in(0,1)$ fixat, $x_p$ cuantila de ordin $p$ asociată lui $F$ și $\hat{x}_p(n)$ cuantila empirică de ordin $p$. Atunci 
  
  1) Convergența: dacă $F$ este strict crescătoare în $x_p$ are loc

$$
  \hat{x}_p(n) \overset{a.s.}{\underset{n\to\infty}\longrightarrow} x_p
$$
  
  2) Normalitatea asiptotică: dacă $F$ este derivabilă în $x_p$ cu derivata $f(x_p)>0$, atunci 

$$
  \sqrt{n}(\hat{x}_p(n) - x_p)\overset{d}{\underset{n\to\infty}\longrightarrow}\mathcal{N}\left(0,\frac{p(1-p)}{f(x_p)^2}\right).
$$
```

Pentru a ilustra importanța condiției de la primul punct ($F$ este strict crescătoare în $x_p$) să considerăm $X\sim\mathcal{B}(\frac{1}{2})$. Atunci mediana sa este $x_{\frac{1}{2}} = 0$ pe când mediana empirică $\hat{x}_{\frac{1}{2}}(n)$ va oscila mereu (dar neregulat) între valorile $0$ și $1$.

```{r, echo=FALSE, out.width = dimplot}
# Normala
N = 10000
step = 10

q2 = qbinom(0.5, 1, 0.5)

n = seq(1, N, step)

q2e = rep(0, length(n))


set.seed(1234)
x = rbinom(N, 1, 0.5)

for (i in seq_along(n)){
  y = x[1:n[i]]
  q2e[i] = quantile(y, probs = 0.5)
}

#-2
plot(n, q2e, type = "l",
     col = "royalblue",
     lty = 1,
     lwd = 2,
     bty = "n", 
     main = TeX("Mediana $\\hat{x}_{0.5}(n)$ pentru $X\\sim B\\left(\\frac{1}{2}\\right)$"),
     xlab = "n", 
     ylab = TeX("\\hat{x}_{0.5}"))

abline(h = q2, 
       col = "brown3", 
       lty = 2, 
       lwd = 2)

```



```{r, type = "rmdexercise", engine = engine_block}
Ilustrați grafic în R proprietatea de convergență și de normalitate asiptotică (din rezultatul precedent) pentru o populație repartizată $\mathcal{N}(0,1)$ și respectiv $\mathcal{E}(3)$ și pentru $p\in\left\{\frac{1}{4}, \frac{1}{2}, \frac{3}{4} \right\}$. 


```

În cazul $\mathcal{N}(0,1)$ avem proprietatea de convergență a cuantilelor

```{r, echo=FALSE, out.width = dimplot}
# Normala
N = 10000
step = 100

q1 = qnorm(0.25)
q2 = qnorm(0.5)
q3 = qnorm(0.75)

n = seq(1, N, step)

q1e = rep(0, length(n))
q2e = rep(0, length(n))
q3e = rep(0, length(n))


set.seed(1234)
x = rnorm(N)

for (i in seq_along(n)){
  y = x[1:n[i]]
  
  q1e[i] = quantile(y, probs = 0.25)
  q2e[i] = quantile(y, probs = 0.5)
  q3e[i] = quantile(y, probs = 0.75)
}

par(mfrow = c(1,3))
#-1
plot(n, q1e, type = "l",
     col = "royalblue",
     lty = 1,
     lwd = 2,
     bty = "n", 
     main = TeX("Convergenta $\\hat{x}_{0.25}(n) \\rightarrow x_{0.25}$"),
     xlab = "n", 
     ylab = TeX("\\hat{x}_{0.25}"))

# points(n, q1e, pch = 16,
#        col = "royalblue")

abline(h = q1, 
       col = "brown3", 
       lty = 2, 
       lwd = 2)
#-2
plot(n, q2e, type = "l",
     col = "royalblue",
     lty = 1,
     lwd = 2,
     bty = "n", 
     main = TeX("Convergenta $\\hat{x}_{0.5}(n) \\rightarrow x_{0.5}$"),
     xlab = "n", 
     ylab = TeX("\\hat{x}_{0.5}"))

# points(n, q2e, pch = 16,
#        col = "royalblue")

abline(h = q2, 
       col = "brown3", 
       lty = 2, 
       lwd = 2)
#-3
plot(n, q3e, type = "l",
     col = "royalblue",
     lty = 1,
     lwd = 2,
     bty = "n", 
     main = TeX("Convergenta $\\hat{x}_{0.75}(n) \\rightarrow x_{0.75}$"),
     xlab = "n", 
     ylab = TeX("\\hat{x}_{0.75}"))

# points(n, q3e, pch = 16,
#        col = "royalblue")

abline(h = q3, 
       col = "brown3", 
       lty = 2, 
       lwd = 2)

```

și proprietatea de normalitate asimptotică

```{r, echo=FALSE, out.width = dimplot2, warning=FALSE}
S = 10000
n = 1250

p1 = 0.25
p2 = 0.5
p3 = 0.75

q1 = qnorm(p1)
q2 = qnorm(p2)
q3 = qnorm(p3)

fxp1 = dnorm(q1)
fxp2 = dnorm(q2)
fxp3 = dnorm(q3)

sd1 = sqrt(p1*(1-p1)/fxp1^2)
sd2 = sqrt(p2*(1-p2)/fxp2^2)
sd3 = sqrt(p3*(1-p3)/fxp3^2)

xp1n = numeric(S) 
xp2n = numeric(S) 
xp3n = numeric(S) 

for (i in 1:S){
  x = rnorm(n)
  xp1n[i] = sqrt(n)*(quantile(x, p1) - q1)
  xp2n[i] = sqrt(n)*(quantile(x, p2) - q2)
  xp3n[i] = sqrt(n)*(quantile(x, p3) - q3)
}

par(mfrow = c(1, 3))

# plot 1 
par(fig = c(0, 1/3, 0, 0.45), bty = "n", new = T)
boxplot(xp1n, horizontal=T, bty="n", xlab = expression(sqrt(n) (hat(x)[0.25] (n) - x[0.25])),
        col = "grey80",
        ylim = c(-4, 4), 
        cex = 0.7)

par(fig = c(0, 1/3, 0.25, 1), new = T)
hist(xp1n, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-4, 4),
     col = "grey80",
     main = TeX("TLC - $\\hat{x}_{0.25}(n)$"),
     xlab = "",
     ylab = "Densitatea")

lines(seq(-4, 4, length.out = 250),
      dnorm(seq(-4, 4, length.out = 250), sd = sd1), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(xp1n)

# plot 2 
par(fig = c(1/3, 2/3, 0, 0.45), bty = "n", new = T)
boxplot(xp2n, horizontal=T, bty="n", xlab = expression(sqrt(n) (hat(x)[0.5] (n) - x[0.5])),
        col = "grey80",
        ylim = c(-4, 4), 
        cex = 0.7)

par(fig = c(1/3, 2/3, 0.25, 1), new = T)
hist(xp2n, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-4, 4),
     col = "grey80",
     main = TeX("TLC - $\\hat{x}_{0.5}(n)$"),
     xlab = "",
     ylab = "Densitatea")

lines(seq(-4, 4, length.out = 250),
      dnorm(seq(-4, 4, length.out = 250), sd = sd2), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(xp2n)

# plot 3
par(fig = c(2/3, 1, 0, 0.45), bty = "n", new = T)
boxplot(xp3n, horizontal=T, bty="n", xlab = expression(sqrt(n) (hat(x)[0.75] (n) - x[0.75])),
        col = "grey80",
        ylim = c(-4, 4), 
        cex = 0.7)

par(fig = c(2/3, 1, 0.25, 1), new = T)
hist(xp3n, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-4, 4),
     col = "grey80",
     main = TeX("TLC - $\\hat{x}_{0.75}(n)$"),
     xlab = "",
     ylab = "Densitatea")

lines(seq(-4, 4, length.out = 250),
      dnorm(seq(-4, 4, length.out = 250), sd = sd3), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(xp3n)

```

În cazul $\mathcal{E}(3)$ avem proprietatea de convergență a cuantilelor

```{r, echo=FALSE, out.width = dimplot}
# Normala
N = 10000
step = 100

q1 = qexp(0.25, 3)
q2 = qexp(0.5, 3)
q3 = qexp(0.75, 3)

n = seq(1, N, step)

q1e = rep(0, length(n))
q2e = rep(0, length(n))
q3e = rep(0, length(n))


set.seed(1234)
x = rexp(N, 3)

for (i in seq_along(n)){
  y = x[1:n[i]]
  
  q1e[i] = quantile(y, probs = 0.25)
  q2e[i] = quantile(y, probs = 0.5)
  q3e[i] = quantile(y, probs = 0.75)
}

par(mfrow = c(1,3))
#-1
plot(n, q1e, type = "l",
     col = "royalblue",
     lty = 1,
     lwd = 2,
     bty = "n", 
     main = TeX("Convergenta $\\hat{x}_{0.25}(n) \\rightarrow x_{0.25}$"),
     xlab = "n", 
     ylab = TeX("\\hat{x}_{0.25}"))

# points(n, q1e, pch = 16,
#        col = "royalblue")

abline(h = q1, 
       col = "brown3", 
       lty = 2, 
       lwd = 2)
#-2
plot(n, q2e, type = "l",
     col = "royalblue",
     lty = 1,
     lwd = 2,
     bty = "n", 
     main = TeX("Convergenta $\\hat{x}_{0.5}(n) \\rightarrow x_{0.5}$"),
     xlab = "n", 
     ylab = TeX("\\hat{x}_{0.5}"))

# points(n, q2e, pch = 16,
#        col = "royalblue")

abline(h = q2, 
       col = "brown3", 
       lty = 2, 
       lwd = 2)
#-3
plot(n, q3e, type = "l",
     col = "royalblue",
     lty = 1,
     lwd = 2,
     bty = "n", 
     main = TeX("Convergenta $\\hat{x}_{0.75}(n) \\rightarrow x_{0.75}$"),
     xlab = "n", 
     ylab = TeX("\\hat{x}_{0.75}"))

# points(n, q3e, pch = 16,
#        col = "royalblue")

abline(h = q3, 
       col = "brown3", 
       lty = 2, 
       lwd = 2)

```

și proprietatea de normalitate asimptotică

```{r, echo=FALSE, out.width = dimplot2, warning=FALSE}
S = 10000
n = 1250

p1 = 0.25
p2 = 0.5
p3 = 0.75

q1 = qexp(p1, 3)
q2 = qexp(p2, 3)
q3 = qexp(p3, 3)

fxp1 = dexp(q1, 3)
fxp2 = dexp(q2, 3)
fxp3 = dexp(q3, 3)

sd1 = sqrt(p1*(1-p1)/fxp1^2)
sd2 = sqrt(p2*(1-p2)/fxp2^2)
sd3 = sqrt(p3*(1-p3)/fxp3^2)

xp1n = numeric(S) 
xp2n = numeric(S) 
xp3n = numeric(S) 

for (i in 1:S){
  x = rexp(n, 3)
  xp1n[i] = sqrt(n)*(quantile(x, p1) - q1)
  xp2n[i] = sqrt(n)*(quantile(x, p2) - q2)
  xp3n[i] = sqrt(n)*(quantile(x, p3) - q3)
}

par(mfrow = c(1, 3))

# plot 1 
par(fig = c(0, 1/3, 0, 0.45), bty = "n", new = T)
boxplot(xp1n, horizontal=T, bty="n", xlab = expression(sqrt(n) (hat(x)[0.25] (n) - x[0.25])),
        col = "grey80",
        ylim = c(-2, 2), 
        cex = 0.7)

par(fig = c(0, 1/3, 0.25, 1), new = T)
hist(xp1n, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-2, 2),
     col = "grey80",
     main = TeX("TLC - $\\hat{x}_{0.25}(n)$"),
     xlab = "",
     ylab = "Densitatea")

lines(seq(-2, 2, length.out = 250),
      dnorm(seq(-2, 2, length.out = 250), sd = sd1), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(xp1n)

# plot 2 
par(fig = c(1/3, 2/3, 0, 0.45), bty = "n", new = T)
boxplot(xp2n, horizontal=T, bty="n", xlab = expression(sqrt(n) (hat(x)[0.5] (n) - x[0.5])),
        col = "grey80",
        ylim = c(-2, 2), 
        cex = 0.7)

par(fig = c(1/3, 2/3, 0.25, 1), new = T)
hist(xp2n, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-2, 2),
     col = "grey80",
     main = TeX("TLC - $\\hat{x}_{0.5}(n)$"),
     xlab = "",
     ylab = "Densitatea")

lines(seq(-2, 2, length.out = 250),
      dnorm(seq(-2, 2, length.out = 250), sd = sd2), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(xp2n)

# plot 3
par(fig = c(2/3, 1, 0, 0.45), bty = "n", new = T)
boxplot(xp3n, horizontal=T, bty="n", xlab = expression(sqrt(n) (hat(x)[0.75] (n) - x[0.75])),
        col = "grey80",
        ylim = c(-2, 2), 
        cex = 0.7)

par(fig = c(2/3, 1, 0.25, 1), new = T)
hist(xp3n, 
     probability = TRUE, 
     # breaks = seq(-4, 4, by = 0.5),
     xlim = c(-2, 2),
     col = "grey80",
     main = TeX("TLC - $\\hat{x}_{0.75}(n)$"),
     xlab = "",
     ylab = "Densitatea")

lines(seq(-2, 2, length.out = 250),
      dnorm(seq(-2, 2, length.out = 250), sd = sd3), 
      type = "l", 
      col = "brown3", lty = 2, lwd = 2)
rug(xp3n)

```


# Metoda grafică: Boxplot 

Una dintre metodele grafice des întâlnite în vizualizarea datelor (cantitative) unidimensionale este *boxplot*-ul (eng. *box and whisker plot* - cutia cu mustăți). Această metodă grafică descriptivă este folosită în principal pentru a investiga forma repartiției (simetrică sau asimetrică) datelor dar și variabilitatea acestora precum și pentru detectarea și ilustrarea schimbărilor de locație și variație între diferitele grupuri de date. 

După cum putem vedea și în figura de mai jos, cutia este definită, de la stânga la dreapta (sau de jos în sus în funcție de cum este reprezentat boxplot-ul: orizontal sau vertical), de prima cuartilă $Q_1$ și de a treia curatilă $Q_3$ ceea ce înseamnă că $50\%$ dintre observații se află în interiorul cutiei. Linia din interiorul cutiei este determinată de mediană sau a doua cuartilă $Q_2$. 

Mustățile care pornesc de o parte și de alta a cutiei sunt determinate astfel (vom folosi conveția folosită de John Tukey^[A se consulta pag. 40-56 din cartea lui John Tukey *Exploratory data analysis*, Addison-Wesley Publishing Company, 1977]): mustața din stânga este determinată de cea mai mică observație mai mare decât $Q_1-1.5 IQR$ iar cea din dreapta de cea mai mare observație din setul de date mai mică decât $Q_3+1.5IQR$, unde $IQR = Q_3-Q_1$ este distanța dintre cuartile (*interquartile range*). 

Valorile observațiilor din setul de date care sunt sau prea mici sau prea mari se numesc valori aberante (*outliers*) și conform lui Tukey sunt definite astfel: *valori strict aberante* care se află la $3IQR$ deasupra celei de-a treia curtilă $Q_3$ sau la $3IQR$ sub prima cuartilă ($x<Q_1-3IQR$ sau $x>Q_3+3IQR$) și *valori potențial aberante* care se află la $1.5IQR$ deasupra celei de-a treia curtilă $Q_3$ sau la $1.5IQR$ sub prima cuartilă ($x<Q_1-1.5IQR$ sau $x>Q_3+1.5IQR$). 

```{r, echo=FALSE, out.width = dimplot, warning=FALSE}
set.seed(1234)

x = rnorm(500)

par(bty = "n", mar = c(1, 1, 1, 1) )

bp = boxplot(x, horizontal = TRUE, 
        axes = FALSE,
        col = grey(0.8, 0.4), 
        ylim = c(-3.5,3.5))

points(c(min(x), max(x)), c(1,1),
       pch = 16)

text(bp$stats[1]-0.25, 1.33, TeX("Cea mai mica observatie\n mai mare decat"), cex = 0.8)
text(bp$stats[1], 1.25, TeX("$Q_1 - 1.5 IQR$"), cex = 0.8)

text(bp$stats[2]-0.3, 1.32, TeX("Prima cuartila"), cex = 0.8)
text(bp$stats[2]-0.25, 1.25, TeX("$(Q_1)$"), cex = 0.7)

text(bp$stats[3], 1.32, TeX("Mediana"), cex = 0.8)
text(bp$stats[3], 1.25, TeX("$(Q_2)$"), cex = 0.7)

text(bp$stats[4]+0.3, 1.32, TeX("A treia cuartila"), cex = 0.8)
text(bp$stats[4]+0.25, 1.25, TeX("$(Q_3)$"), cex = 0.7)

text(bp$stats[5]+0.25, 1.33, TeX("Cea mai mare observatie\n mai mica decat"), cex = 0.8)
text(bp$stats[5], 1.25, TeX("$Q_3 + 1.5 IQR$"), cex = 0.8)


text(min(x)-0.1, 1.1, "Valoarea\n minima", cex = 0.7)
text(max(x)+0.1, 1.1, "Valoarea\n maxima", cex = 0.7)


text(bp$stats[3], 0.7, TeX("$IQR = Q_3 - Q_1$"), cex = 0.8)

s.bp.out = sort(bp$out)

arrows(min(x)+0.2, 0.72, s.bp.out[1], 0.98, length = 0.13, angle = 15, col = "grey30")
arrows(min(x)+0.2, 0.72, s.bp.out[2], 0.98, length = 0.13, angle = 15, col = "grey30")
arrows(min(x)+0.2, 0.72, s.bp.out[3], 0.98, length = 0.13, angle = 15, col = "grey30")
arrows(min(x)+0.2, 0.72, s.bp.out[4], 0.98, length = 0.13, angle = 15, col = "grey30")

text(min(x)+0.2, 0.67, "Valori potential\n aberante", cex = 0.8)

arrows(max(x)-0.1, 0.72, s.bp.out[6], 0.98, length = 0.13, angle = 15, col = "grey30")
arrows(max(x)-0.1, 0.72, s.bp.out[7], 0.98, length = 0.13, angle = 15, col = "grey30")
arrows(max(x)-0.1, 0.72, s.bp.out[8], 0.98, length = 0.13, angle = 15, col = "grey30")

text(max(x)-0.2, 0.67, "Valori potential\n aberante", cex = 0.8)

```


În R metoda grafică boxplot se poate trasa cu ajutorul funcției `boxplot()`. Aceasta primește ca argumente sau un vector de observații numerice `x` atunci când dorim să ilustrăm repartiția unei variabile sau o formulă de tipul `y~grup`, unde `y` este un vector numeric care va fi împărțit în funcție de variabila discretă `grup`, atunci când vrem să comparăm aceeași variabilă numerică în funcție de una discretă (calitatăvă). Pentru mai multe informații tastați `?boxplot`.

```{r, type = "rmdexercise", engine = engine_block}
Considerați setul de date `mtcars`. Investigați cu ajutorul unui boxplot cum variază greutatea mașinilor, variabila `wt`, în funcție de numărul de cilindrii `cyl`. Afișați numele mașinilor care prezintă potențiale valori aberante. Aceeași cerință pentru perechile `mpg` - `cyl`, `hp` - `cyl` și `hp` - `am`. 
```

```{r, echo=FALSE, out.width = dimplot, warning=FALSE}
par(bty = "n")
bp = boxplot(mtcars$wt ~ mtcars$cyl,
             xlab = "Numar de cilindrii", 
             ylab = "Greutate (in tone)",
             col = "grey80",
             main = "Setul de date mtcars: greutate vs numar cilindrii")

cars = mtcars[mtcars$cyl == 8, ]
cars.names = rownames(cars)[which(cars$wt %in% bp$out)]

text(c(3,3,2.4)+0.3, bp$out, cars.names, cex = 0.6)
text( c(1:length(unique(mtcars$cyl))) , 
      bp$stats[nrow(bp$stats) , ] + 0.5 , 
      paste("n = ", table(mtcars$cyl),sep=""),
      cex = 0.8)
```

Numele mașinilor care au o greutate potențial aberantă este `r paste0(cars.names, collapse = ", ")`.


