\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={Laborator 3},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}
  \title{Laborator 3}
  \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
\subtitle{Elemente de probabilități și simulare în R}
  \author{}
  \preauthor{}\postauthor{}
  \date{}
  \predate{}\postdate{}

\usepackage{booktabs}
\usepackage{longtable}
\usepackage{framed,color}
\definecolor{shadecolor}{RGB}{248, 248, 248}
\definecolor{shadecolor1}{RGB}{216,225,235}
\definecolor{framecolor}{RGB}{108,123,13}

\ifxetex
  \usepackage{letltxmacro}
  \setlength{\XeTeXLinkMargin}{1pt}
  \LetLtxMacro\SavedIncludeGraphics\includegraphics
  \def\includegraphics#1#{% #1 catches optional stuff (star/opt. arg.)
    \IncludeGraphicsAux{#1}%
  }%
  \newcommand*{\IncludeGraphicsAux}[2]{%
    \XeTeXLinkBox{%
      \SavedIncludeGraphics#1{#2}%
    }%
  }%
\fi

\newenvironment{frshaded*}{%
  \def\FrameCommand{\fboxrule=\FrameRule\fboxsep=\FrameSep \fcolorbox{framecolor}{shadecolor1}}%
  \MakeFramed {\advance\hsize-\width \FrameRestore}}%
{\endMakeFramed}

\newenvironment{rmdblock}[1]
  {\begin{frshaded*}
  \begin{itemize}
  \renewcommand{\labelitemi}{
    \raisebox{-.7\height}[0pt][0pt]{
      {\setkeys{Gin}{width=2em,keepaspectratio}\includegraphics{images/icons/#1}}
    }
  }
  \item
  }
  {
  \end{itemize}
  \end{frshaded*}
  }
  
\newenvironment{rmdcaution}
  {\begin{rmdblock}{caution}}
  {\end{rmdblock}}
% \newenvironment{rmdinsight}
%   {\begin{rmdblock}{insight}}
%   {\end{rmdblock}}
\newenvironment{rmdexercise}
  {\begin{rmdblock}{exercise}}
  {\end{rmdblock}}
\newenvironment{rmdtip}
  {\begin{rmdblock}{tip}}
  {\end{rmdblock}}
  
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% For insight block %%%%%%%%%%%%%%%%%%%%%%%%%%
\definecolor{shadecolor_insight}{RGB}{223,240,216}
\definecolor{framecolor_insight}{RGB}{136,193,137}

\newenvironment{frshaded_insight*}{%
  \def\FrameCommand{\fboxrule=\FrameRule\fboxsep=\FrameSep \fcolorbox{framecolor_insight}{shadecolor_insight}}%
  \MakeFramed {\advance\hsize-\width \FrameRestore}}%
{\endMakeFramed}

\newenvironment{rmdblock_insight}[1]
  {\begin{frshaded_insight*}
  \begin{itemize}
  \renewcommand{\labelitemi}{
    \raisebox{-.7\height}[0pt][0pt]{
      {\setkeys{Gin}{width=2em,keepaspectratio}\includegraphics{images/icons/#1}}
    }
  }
  \item
  }
  {
  \end{itemize}
  \end{frshaded_insight*}
  }
  
\newenvironment{rmdinsight}
  {\begin{rmdblock_insight}{insight}}
  {\end{rmdblock_insight}}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{slashbox}
\usepackage{color}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%CITEVA DEFINITII
\def\om{\omega}
\def\Om{\Omega}
\def\et{\eta}
\def\td{\tilde{\delta}}
\def\m{{\mu}}
\def\n{{\nu}}
\def\k{{\kappa}}
\def\l{{\lambda}}
\def\L{{\Lambda}}
\def\g{{\gamma}}
\def\a{{\alpha}}
\def\e{{\varepsilon}}
\def\b{{\beta}}
\def\G{{\Gamma}}
\def\d{{\delta}}
\def\D{{\Delta}}
\def\t{{\theta}}
\def\s{{\sigma}}
\def\S{{\Sigma}}
\def\z{{\zeta}}
\def\qed{\hfill\Box}
\def\ds{\displaystyle}
\def\mc{\mathcal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\1{{\mathbf 1}}
\def\CC{{\mathbb C}}
\def\VV{{\mathbb V}}
\def\RR{{\mathbb R}}
\def\QQ{{\mathbb Q}}
\def\ZZ{{\mathbb Z}}
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}}
\def\NN{{\mathbb N}}
\def\FF{{\mathbb F}}
%\def\SS{{\mathbb S}}
\def\MA{{\mathcal A}}
\def\MO{{\mathcal O}}
\def\MF{{\mathcal F}}
\def\ME{{\mathcal E}}
\def\MR{{\mathcal R}}
\def\MB{{\mathcal B}}
\def\MM{{\mathcal M}}
\def\MN{{\mathcal N}}
\def\MU{{\mathcal U}}
\def\MP{{\mathcal P}}
\def\MS{{\mathcal S}}
\def\MBS{{\mathbf S}}
\def\MX{{\bm{ \mathscr X}}}

% independent sign
\newcommand\independent{\protect\mathpalette{\protect\independenT}{\perp}}
\def\independenT#1#2{\mathrel{\rlap{$#1#2$}\mkern2mu{#1#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Header and Footer
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{Universitatea din Bucure\c sti\\ Facultatea de Matematic\u a \c si Informatic\u a}
\lhead{\textit{Curs}: Statistic\u a\\ \textit{Instructori}: A. Am\u arioarei, S. Cojocea}
\rfoot{Pagina \thepage}
\lfoot{Grupele: 301, 311, 321}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{fancy}

Obiectivul acestui laborator este de a prezenta succint câteva funcții
utile teoriei probabilităților din programul
\href{https://cran.r-project.org/}{R}, care este structura lor și cum le
putem aplica. De asemenea, tot în acest laborator vom prezenta și câteva
probleme de simulare.

\section{\texorpdfstring{Familia de funcții
\texttt{apply}}{Familia de funcții apply}}\label{familia-de-functii-apply}

Pe lângă buclele \texttt{for} și \texttt{while}, în R există și un set
de funcții care permit scrierea și rularea într-o manieră mai compactă a
codului dar și aplicarea de funcții unor grupuri de date.

\begin{itemize}
\item
  \texttt{lapply()}: Evaluează o funcție pentru fiecare element al unei
  liste
\item
  \texttt{sapply()}: La fel ca \texttt{lapply} numai că încearcă să
  simplifice rezultatul
\item
  \texttt{apply()}: Aplică o funcție după fiecare dimensiune a unui
  \texttt{array}
\item
  \texttt{tapply()}: Aplică o funcție pe submulțimi ale unui vector
\item
  \texttt{mapply()}: Varianta multivariată a funcției \texttt{lapply}
\item
  \texttt{split}: Împarte un vector în grupuri definite de o variabilă
  de tip factor.
\end{itemize}

\subsection{\texorpdfstring{\texttt{lapply()}}{lapply()}}\label{lapply}

Funcția \texttt{lapply()} efectuează următoarele operații:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  buclează după o listă, iterând după fiecare element din acea listă
\item
  aplică o \emph{funcție} fiecărui element al listei (o funcție pe care
  o specificăm)
\item
  întoarce ca rezultat tot o listă (prefixul \texttt{l} vine de la
  listă).
\end{enumerate}

Această funcție primește următoarele trei argument: (1) o listă
\texttt{X}; (2) o funcție \texttt{FUN}; (3) alte argumente via
\texttt{...}. Dacă \texttt{X} nu este o listă atunci aceasta va fi
transformată într-una folosind comanda \texttt{as.list()}.

Considerăm următorul exemplu în care vrem să aplicăm funcția
\texttt{mean()} tuturor elementelor unei liste

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{222}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{b =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{), }\DataTypeTok{c =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{d =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\KeywordTok{lapply}\NormalTok{(x, mean)}
\OperatorTok{$}\NormalTok{a}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\DecValTok{3}

\OperatorTok{$}\NormalTok{b}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.1996044}

\OperatorTok{$}\NormalTok{c}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.7881026}

\OperatorTok{$}\NormalTok{d}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{5.064188}
\end{Highlighting}
\end{Shaded}

Putem să folosim funcția \texttt{lapply()} pentru a evalua o funcție în
moduri repetate. Mai jos avem un exemplu în care folosim funcția
\texttt{runif()} (permite generarea observațiilor uniform repartizate)
de patru ori, de fiecare dată generăm un număr diferit de valori
aleatoare. Mai mult, argumentele \(min=0\) și \(max=3\) sunt atribuite,
prin intermediul argumentului \texttt{...}, funcției \texttt{runif}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\KeywordTok{lapply}\NormalTok{(x, runif, }\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{3}\NormalTok{)}
\NormalTok{[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.03443616}

\NormalTok{[[}\DecValTok{2}\NormalTok{]]}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{1.267361} \FloatTok{1.365441}

\NormalTok{[[}\DecValTok{3}\NormalTok{]]}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{1.8084700} \FloatTok{2.1902665} \FloatTok{0.4139585}

\NormalTok{[[}\DecValTok{4}\NormalTok{]]}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{1.5924650} \FloatTok{0.7355067} \FloatTok{2.1483841} \FloatTok{1.6082945}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{sapply()}}{sapply()}}\label{sapply}

Funcția \texttt{sapply()} are un comportament similar cu
\texttt{lapply()} prin faptul că funcția \texttt{sapply()} apelează
intern \texttt{lapply()} pentru valorile de input, după care evaluează:

\begin{itemize}
\item
  dacă rezultatul este o listă în care fiecare element este de lungime
  1, atunci întoarce un vector
\item
  dacă rezultatul este o listă în care fiecare element este un vector de
  aceeași lungime (\textgreater{}1), se întoarce o matrice
\item
  în caz contrar se întoarce o listă.
\end{itemize}

Considerăm exemplul de mai sus

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{222}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{b =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{), }\DataTypeTok{c =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{d =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\KeywordTok{sapply}\NormalTok{(x, mean)}
\NormalTok{        a         b         c         d }
\FloatTok{2.5000000} \FloatTok{0.1996044} \FloatTok{0.7881026} \FloatTok{5.0641876} 
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{split()}}{split()}}\label{split}

Funcția \texttt{split()} primește ca argument un vector sau o listă (sau
un data.frame) și împarte datele în grupuri determinate de o variabilă
de tip factor (sau o listă de factor).

Argumentele aceste funcții sunt

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(split)}
\ControlFlowTok{function}\NormalTok{ (x, f, }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{, ...)  }
\end{Highlighting}
\end{Shaded}

unde

\begin{itemize}
\tightlist
\item
  \texttt{x} este un vector, o listă sau un data.frame
\item
  \texttt{f} este un factor sau o listă de factori
\end{itemize}

Considerăm următorul exemplu în care generăm un vector de date și îl
împărțim după o variabilă de tip factor creată cu ajutorul funcției
\texttt{gl()} (\emph{generate levels}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{), }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{), }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\NormalTok{f <-}\StringTok{ }\KeywordTok{gl}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\KeywordTok{split}\NormalTok{(x, f)}
\OperatorTok{$}\StringTok{`}\DataTypeTok{1}\StringTok{`}
\NormalTok{ [}\DecValTok{1}\NormalTok{] }\OperatorTok{-}\FloatTok{2.27414224} \OperatorTok{-}\FloatTok{0.11266780}  \FloatTok{0.61308167}  \FloatTok{0.07733545}  \FloatTok{0.57137727}
\NormalTok{ [}\DecValTok{6}\NormalTok{]  }\FloatTok{0.11672493} \OperatorTok{-}\FloatTok{0.95685256} \OperatorTok{-}\FloatTok{1.90008460} \OperatorTok{-}\FloatTok{1.48972089}  \FloatTok{0.55925676}

\OperatorTok{$}\StringTok{`}\DataTypeTok{2}\StringTok{`}
\NormalTok{ [}\DecValTok{1}\NormalTok{] }\FloatTok{0.91159086} \FloatTok{0.03291829} \FloatTok{0.78368939} \FloatTok{0.11852882} \FloatTok{0.64443831} \FloatTok{0.78790988}
\NormalTok{ [}\DecValTok{7}\NormalTok{] }\FloatTok{0.82451477} \FloatTok{0.05642366} \FloatTok{0.65075027} \FloatTok{0.95426854}

\OperatorTok{$}\StringTok{`}\DataTypeTok{3}\StringTok{`}
\NormalTok{ [}\DecValTok{1}\NormalTok{]  }\FloatTok{2.6666242}  \FloatTok{2.6634334}  \FloatTok{1.8106280} \OperatorTok{-}\FloatTok{0.7837308}  \FloatTok{1.6575684}  \FloatTok{0.1546575}
\NormalTok{ [}\DecValTok{7}\NormalTok{]  }\FloatTok{0.4930056} \OperatorTok{-}\FloatTok{0.9031544}  \FloatTok{2.4042311}  \FloatTok{1.4106863}
\end{Highlighting}
\end{Shaded}

Putem folosi funcția \texttt{split} și în conjuncție cu funcția
\texttt{lapply} (atunci când vrem să aplicăm o funcție \texttt{FUN} pe
grupuri de date).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(}\KeywordTok{split}\NormalTok{(x, f), mean)}
\OperatorTok{$}\StringTok{`}\DataTypeTok{1}\StringTok{`}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\OperatorTok{-}\FloatTok{0.4795692}

\OperatorTok{$}\StringTok{`}\DataTypeTok{2}\StringTok{`}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.5765033}

\OperatorTok{$}\StringTok{`}\DataTypeTok{3}\StringTok{`}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{1.157395}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{tapply()}}{tapply()}}\label{tapply}

Funcția \texttt{tapply()} este folosită pentru aplicarea unei funcții
\texttt{FUN} pe submulțimile unui vector și poate fi văzută ca o
combinație între \texttt{split()} și \texttt{sapply()}, dar doar pentru
vectori.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(tapply)}
\ControlFlowTok{function}\NormalTok{ (X, INDEX, }\DataTypeTok{FUN =} \OtherTok{NULL}\NormalTok{, ..., }\DataTypeTok{default =} \OtherTok{NA}\NormalTok{, }\DataTypeTok{simplify =} \OtherTok{TRUE}\NormalTok{)  }
\end{Highlighting}
\end{Shaded}

Argumentele acestei funcții sunt date de următorul tabel:

\begin{longtable}[]{@{}ll@{}}
\caption{Argumentele functiei tapply}\tabularnewline
\toprule
Argument & Descriere\tabularnewline
\midrule
\endfirsthead
\toprule
Argument & Descriere\tabularnewline
\midrule
\endhead
\texttt{X} & un vector\tabularnewline
\texttt{INDEX} & este o variabilă de tip factor sau o listă de
factori\tabularnewline
\texttt{FUN} & o funcție ce urmează să fie aplicată\tabularnewline
\texttt{...} & argumente ce vor fi atribuite funcției
\texttt{FUN}\tabularnewline
\texttt{simplify} & dacă vrem să simplificăm rezultatul\tabularnewline
\bottomrule
\end{longtable}

Următorul exemplu calculează media după fiecare grupă determinată de o
variabilă de tip factor a unui vector numeric.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{), }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{), }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\NormalTok{f <-}\StringTok{ }\KeywordTok{gl}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{10}\NormalTok{)   }
\NormalTok{f}
\NormalTok{ [}\DecValTok{1}\NormalTok{] }\DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{2} \DecValTok{3} \DecValTok{3} \DecValTok{3} \DecValTok{3} \DecValTok{3} \DecValTok{3} \DecValTok{3} \DecValTok{3} \DecValTok{3} \DecValTok{3}
\NormalTok{Levels}\OperatorTok{:}\StringTok{ }\DecValTok{1} \DecValTok{2} \DecValTok{3}
\KeywordTok{tapply}\NormalTok{(x, f, mean)}
            \DecValTok{1}             \DecValTok{2}             \DecValTok{3} 
\OperatorTok{-}\FloatTok{0.0007774025}  \FloatTok{0.3736457792}  \FloatTok{0.5789436983} 
\end{Highlighting}
\end{Shaded}

Putem să aplicăm și funcții care întorc mai mult de un rezultat. În
această situație rezultatul nu poate fi simplificat:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tapply}\NormalTok{(x, f, range)}
\OperatorTok{$}\StringTok{`}\DataTypeTok{1}\StringTok{`}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\OperatorTok{-}\FloatTok{2.1904113}  \FloatTok{0.9249901}

\OperatorTok{$}\StringTok{`}\DataTypeTok{2}\StringTok{`}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.004445296} \FloatTok{0.998309704}

\OperatorTok{$}\StringTok{`}\DataTypeTok{3}\StringTok{`}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\OperatorTok{-}\FloatTok{0.3379675}  \FloatTok{1.9327099}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{apply()}}{apply()}}\label{apply}

Funcția \texttt{apply()} este folosită cu precădere pentru a aplica o
funcție liniilor și coloanelor unei matrice (care este un \texttt{array}
bidimensional). Cu toate acestea poate fi folosită pe tablouri
multidimensionale (\texttt{array}) în general. Folosirea funcției
\texttt{apply()} nu este mai rapidă decât scrierea unei bucle
\texttt{for}, dar este mai compactă.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(apply)}
\ControlFlowTok{function}\NormalTok{ (X, MARGIN, FUN, ...)  }
\end{Highlighting}
\end{Shaded}

Argumentele funcției \texttt{apply()} sunt

\begin{itemize}
\tightlist
\item
  \texttt{X} un tablou multidimensional
\item
  \texttt{MARGIN} este un vector numeric care indică dimensiunea sau
  dimensiunile după care se va aplica funcția
\item
  \texttt{FUN} este o funcție ce urmează să fie aplicată
\item
  \texttt{...} alte argumente penru funcția\texttt{FUN}
\end{itemize}

Considerăm următorul exemplu în care calculăm media pe coloane într-o
matrice

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{200}\NormalTok{), }\DecValTok{20}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\KeywordTok{apply}\NormalTok{(x, }\DecValTok{2}\NormalTok{, mean)  ## media fiecarei coloane}
\NormalTok{ [}\DecValTok{1}\NormalTok{]  }\FloatTok{3.745002e-02}  \FloatTok{1.857656e-01} \OperatorTok{-}\FloatTok{2.413659e-01} \OperatorTok{-}\FloatTok{2.093141e-01} \OperatorTok{-}\FloatTok{2.562272e-01}
\NormalTok{ [}\DecValTok{6}\NormalTok{]  }\FloatTok{8.986712e-05}  \FloatTok{7.444137e-02} \OperatorTok{-}\FloatTok{7.460941e-03}  \FloatTok{6.275282e-02}  \FloatTok{9.801550e-02}
\end{Highlighting}
\end{Shaded}

precum și media după fiecare linie

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(x, }\DecValTok{1}\NormalTok{, sum)   ## media fiecarei linii}
\NormalTok{ [}\DecValTok{1}\NormalTok{]  }\FloatTok{2.76179139}  \FloatTok{2.53107681}  \FloatTok{0.87923177}  \FloatTok{1.80480589}  \FloatTok{0.98225832}
\NormalTok{ [}\DecValTok{6}\NormalTok{] }\OperatorTok{-}\FloatTok{3.06148753} \OperatorTok{-}\FloatTok{1.40358820} \OperatorTok{-}\FloatTok{0.65969812} \OperatorTok{-}\FloatTok{1.63717046} \OperatorTok{-}\FloatTok{0.29330726}
\NormalTok{[}\DecValTok{11}\NormalTok{] }\OperatorTok{-}\FloatTok{2.41486442} \OperatorTok{-}\FloatTok{3.15698523}  \FloatTok{2.27126822} \OperatorTok{-}\FloatTok{3.88290287} \OperatorTok{-}\FloatTok{3.15595194}
\NormalTok{[}\DecValTok{16}\NormalTok{]  }\FloatTok{5.41211963}  \FloatTok{2.32985530} \OperatorTok{-}\FloatTok{3.05330574} \OperatorTok{-}\FloatTok{0.02110926} \OperatorTok{-}\FloatTok{1.34909559}
\end{Highlighting}
\end{Shaded}

\section{Repartiții și elemente aleatoare în
R}\label{repartitii-si-elemente-aleatoare-in-r}

R pune la disploziție majoritatea repartițiilor uzuale. Tabelul de mai
jos prezintă numele și parametrii acestora:

\begin{longtable}[]{@{}llll@{}}
\caption{Numele si parametrii repartitiilor uzuale in R}\tabularnewline
\toprule
Repartiția & Nume & Parametrii & Valori prestabilite\tabularnewline
\midrule
\endfirsthead
\toprule
Repartiția & Nume & Parametrii & Valori prestabilite\tabularnewline
\midrule
\endhead
Beta & \texttt{beta} & \texttt{shape1}, \texttt{shape2} &\tabularnewline
Binomial & \texttt{binom} & \texttt{size}, \texttt{prob}
&\tabularnewline
Cauchy & \texttt{cauchy} & \texttt{location}, \texttt{scale} &
\texttt{location\ =\ 0}, \texttt{scale\ =\ 1}\tabularnewline
Chi-Squared & \texttt{chisq} & \texttt{df} &\tabularnewline
Exponential & \texttt{exp} & \texttt{rate} (=1/mean) &
\texttt{rate\ =\ 1}\tabularnewline
Fisher & \texttt{f} & \texttt{df1}, \texttt{df2} &\tabularnewline
Gamma & \texttt{gamma} & \texttt{shape}, \texttt{rate} (=1/scale) &
\texttt{rate\ =\ 1}\tabularnewline
Hypergeometric & \texttt{hyper} & \texttt{m}, \texttt{n}, \texttt{k}
&\tabularnewline
Log-Normal & \texttt{lnorm} & \texttt{mean}, \texttt{sd} &
\texttt{mean\ =\ 0}, \texttt{sd\ =\ 1}\tabularnewline
Logistic & \texttt{logis} & \texttt{location}, \texttt{scale} &
\texttt{location\ =\ 0}, \texttt{scale\ =\ 1}\tabularnewline
Normal & \texttt{norm} & \texttt{mean}, \texttt{sd} &
\texttt{mean\ =\ 0}, \texttt{sd\ =\ 1}\tabularnewline
Poisson & \texttt{pois} & \texttt{lambda} &\tabularnewline
Student & \texttt{t} & \texttt{df} &\tabularnewline
Uniform & \texttt{unif} & \texttt{min}, \texttt{max} &
\texttt{min\ =\ 0}, \texttt{max\ =\ 1}\tabularnewline
Weibull & \texttt{weibull} & \texttt{shape} &\tabularnewline
\bottomrule
\end{longtable}

Pentru fiecare repartiție, există patru comenzi în R prefixate cu
literele \texttt{d}, \texttt{p}, \texttt{q} și \texttt{r} și urmate de
numele repartiției (coloana a 2-a). De exemplu \texttt{dnorm},
\texttt{pnorm}, \texttt{qnorm} și \texttt{rnorm} sunt comenzile
corespunzătoare repartiției normale pe când \texttt{dunif},
\texttt{punif}, \texttt{qunif} și \texttt{runif} sunt cele
corespunzătoare repartiției uniforme.

\begin{itemize}
\item
  \texttt{dname}: calculează densitatea atunci când vorbim de o
  variabilă continue sau funcția de masă atunci când avem o repartiție
  discretă (\(\mathbb{P}(X=k)\))
\item
  \texttt{pname}: calculează funcția de repartiție, i.e.
  \(F(x)=\mathbb{P}(X\leq x)\)
\item
  \texttt{qname}: reprezintă funcția cuantilă, cu alte cuvinte valoarea
  pentru care funcția de repartiție are o anumită probabilitate; în
  cazul continuu, dacă \texttt{pname(x)\ =\ p} atunci
  \texttt{qname(p)\ =\ x} iar în cazul discret întoarce cel mai mic
  întreg \(u\) pentru care \(\mathbb{P}(X\leq u)\geq p\).
\item
  \texttt{rname}: generează observații independente din repartiția dată
\end{itemize}

Avem următoarele exemple:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{qnorm}\NormalTok{(}\FloatTok{0.975}\NormalTok{)}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{1.959964}
\KeywordTok{pnorm}\NormalTok{(}\FloatTok{1.96}\NormalTok{)}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.9750021}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.4304737} \FloatTok{0.8405027} \FloatTok{1.9550682} \FloatTok{1.6208507} \FloatTok{2.1059503}

\NormalTok{x =}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.25}\NormalTok{)}
\KeywordTok{dnorm}\NormalTok{(x)}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.2419707} \FloatTok{0.3011374} \FloatTok{0.3520653} \FloatTok{0.3866681} \FloatTok{0.3989423} \FloatTok{0.3866681} \FloatTok{0.3520653}
\NormalTok{[}\DecValTok{8}\NormalTok{] }\FloatTok{0.3011374} \FloatTok{0.2419707}
\KeywordTok{rnorm}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\FloatTok{0.5}\NormalTok{)}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{5.327249} \FloatTok{4.728878} \FloatTok{5.773167}

\KeywordTok{dunif}\NormalTok{(x)}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\DecValTok{0} \DecValTok{0} \DecValTok{0} \DecValTok{0} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1} \DecValTok{1}
\KeywordTok{runif}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.6353840} \FloatTok{0.8470974} \FloatTok{0.0672359}
\end{Highlighting}
\end{Shaded}

\section{Exerciții propuse}\label{exercitii-propuse}

\subsection{Aruncarea cu banul}\label{aruncarea-cu-banul}

În acest exemplu vrem să simulăm aruncarea unei monede (echilibrate)
folosind funcția \texttt{sample()}. Această funcție permite extragerea,
cu sau fără întoarcere (\texttt{replace\ =\ TRUE} sau
\texttt{replace\ =\ FALSE} - aceasta este valoarea prestabilită), a unui
eșantion de volum dat (\texttt{size}) dintr-o mulțime de elemente
\texttt{x}.

Spre exemplu dacă vrem să simulăm \(10\) aruncări cu banul atunci
apelăm:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"H"}\NormalTok{, }\StringTok{"T"}\NormalTok{), }\DecValTok{10}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{ [}\DecValTok{1}\NormalTok{] }\StringTok{"T"} \StringTok{"T"} \StringTok{"T"} \StringTok{"T"} \StringTok{"T"} \StringTok{"T"} \StringTok{"T"} \StringTok{"H"} \StringTok{"H"} \StringTok{"T"}
\end{Highlighting}
\end{Shaded}

Pentru a estima probabilitatea de apariției a stemei (\texttt{H})
repetăm aruncarea cu banul de \(10000\) de ori și calculăm raportul
dintre numărul de apariții ale evenimentului \(A=\{H\}\) și numărul
total de aruncări:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# atunci cand moneda este echilibrata}
\NormalTok{a =}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"H"}\NormalTok{,}\StringTok{"T"}\NormalTok{), }\DecValTok{10000}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{p =}\StringTok{ }\KeywordTok{sum}\NormalTok{(a }\OperatorTok{==}\StringTok{ "H"}\NormalTok{)}\OperatorTok{/}\KeywordTok{length}\NormalTok{(a)}
\NormalTok{p}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.5073}
\end{Highlighting}
\end{Shaded}

și pentru cazul în care moneda nu este echilibrată

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a =}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"H"}\NormalTok{,}\StringTok{"T"}\NormalTok{), }\DecValTok{10000}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{prob =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.2}\NormalTok{, }\FloatTok{0.8}\NormalTok{))}
\NormalTok{p =}\StringTok{ }\KeywordTok{sum}\NormalTok{(a }\OperatorTok{==}\StringTok{ "H"}\NormalTok{)}\OperatorTok{/}\KeywordTok{length}\NormalTok{(a)}
\NormalTok{p}
\NormalTok{[}\DecValTok{1}\NormalTok{] }\FloatTok{0.2012}
\end{Highlighting}
\end{Shaded}

Putem vedea cum evoluează această probabilitatea în funcție de numărul
de repetări

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y =}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{100}\NormalTok{)}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{)\{}
\NormalTok{  a =}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"H"}\NormalTok{,}\StringTok{"T"}\NormalTok{), i}\OperatorTok{*}\DecValTok{100}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  y[i] =}\StringTok{ }\KeywordTok{sum}\NormalTok{(a }\OperatorTok{==}\StringTok{ "H"}\NormalTok{)}\OperatorTok{/}\KeywordTok{length}\NormalTok{(a)}
\NormalTok{\}}

\KeywordTok{plot}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, y, }\DataTypeTok{type =} \StringTok{"o"}\NormalTok{, }\DataTypeTok{col =} \StringTok{"royalblue"}\NormalTok{, }\DataTypeTok{bty =} \StringTok{"n"}\NormalTok{,}
     \DataTypeTok{xlab =}\StringTok{""}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"probabilitatea"}\NormalTok{)}
\KeywordTok{abline}\NormalTok{(}\DataTypeTok{h =} \FloatTok{0.5}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{col =} \StringTok{"brown3"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-18-1} \end{center}

\subsection{Jocul de loto}\label{jocul-de-loto}

\begin{rmdexercise}
Construiți în R o funcție care să simuleze jocul de loto \(6/49\). Acest
joc consistă din extragerea aleatoare a \(6\) numere dintr-o urnă cu
\(49\) de numere posibile, fără întoarcere. Fiecare extragere se face de
manieră uniformă din numerele rămase în urnă (la a i-a extragere fiecare
bilă din urnă are aceeași șansă să fie extrasă). De exemplu putem avea
următorul rezultat: \(10, 27, 3, 45, 12, 24\).

\textbf{Notă}: Funcția \texttt{sample()} poate face această operație,
ceea ce se cere este de a crea voi o funcție care să implementeze jocul
fără a folosi funcția \emph{sample}. Binențeles că puteți folosi funcții
precum: \texttt{runif} , \texttt{floor}, \texttt{choose}, etc.
\end{rmdexercise}

Începem prin a construi o funcție care ne permite generarea unei
variabile aleatoare uniform repartizate pe mulțimea \(\{1,2,\dots,n\}\)
(această funcție este cea care simulează procesul de extragere de la
fiecare pas):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myintunif =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n)\{}
  \CommentTok{# dunctia care genereaza un numar uniform intre 1 si n}
\NormalTok{  r =}\StringTok{ }\NormalTok{n}\OperatorTok{*}\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{  u =}\StringTok{ }\KeywordTok{floor}\NormalTok{(r)}\OperatorTok{+}\DecValTok{1}
  \KeywordTok{return}\NormalTok{(u)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Funcția care realizează extragerea fără întoarcere a \(k\) numere
aleatoare din \(n\), este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myrandsample=}\ControlFlowTok{function}\NormalTok{(n,k)\{}
  \CommentTok{# }
\NormalTok{  x =}\StringTok{ }\DecValTok{1}\OperatorTok{:}\NormalTok{n}
\NormalTok{  q =}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{,k)}
  
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{k)\{}
\NormalTok{    l =}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{    u =}\StringTok{ }\KeywordTok{myintunif}\NormalTok{(l)}
\NormalTok{    q[i] =}\StringTok{ }\NormalTok{x[u]}
\NormalTok{    x =}\StringTok{ }\NormalTok{x[x}\OperatorTok{!=}\NormalTok{q[i]]}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(q)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Pentru a vedea ce face această funcție putem scrie:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n =}\StringTok{ }\DecValTok{49}
\NormalTok{k =}\StringTok{ }\DecValTok{6}

\KeywordTok{myrandsample}\NormalTok{(n,k)}
\NormalTok{[}\DecValTok{1}\NormalTok{]  }\DecValTok{3} \DecValTok{16} \DecValTok{12} \DecValTok{48} \DecValTok{23} \DecValTok{32}
\end{Highlighting}
\end{Shaded}

\subsection{Generarea variabilelor aleatoare
discrete}\label{generarea-variabilelor-aleatoare-discrete}

\begin{rmdexercise}
În acest exercițiu ne propunem să definim o funcție
\texttt{rand\_sample(n,x,p)} care permite generarea a \(n\) observații
dintr-o mulțime \(x\) (vector numeric sau de caractere) cu
probabilitatea \(p\) pe \(x\) (un vector de aceeași lungime ca \(x\)).
\end{rmdexercise}

Funcția se poate construi sub forma următoare:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rand_sample =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n,x,p)\{}
  \CommentTok{# n - numarul de observatii}
  \CommentTok{# x - multimea de valori}
  \CommentTok{# p - vectorul de probabilitati}
  
\NormalTok{  out =}\StringTok{ }\KeywordTok{c}\NormalTok{()}
  
\NormalTok{  ind =}\StringTok{ }\DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)}
\NormalTok{  cs =}\StringTok{ }\KeywordTok{cumsum}\NormalTok{(p) }
  
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x)}\OperatorTok{!=}\KeywordTok{length}\NormalTok{(p))\{}
    \KeywordTok{return}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\StringTok{'Cei doi vectori ar trebui sa fie de aceeasi lungime !'}\NormalTok{))}
\NormalTok{  \}}
  
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n)\{}
\NormalTok{    r =}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)}
    
\NormalTok{    m =}\StringTok{ }\KeywordTok{min}\NormalTok{(ind[r}\OperatorTok{<=}\NormalTok{cs])}
\NormalTok{    out =}\StringTok{ }\KeywordTok{c}\NormalTok{(out,x[m])}
\NormalTok{  \}}
  
  \KeywordTok{return}\NormalTok{(out)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Pentru a testa această funcție să considerăm două exemple:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  în acest caz: \(n=10\), \(x=[1,2,3]\) și \(p=[0.2,0.3,0.5]\)
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rand_sample}\NormalTok{(}\DecValTok{10}\NormalTok{,}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{),}\KeywordTok{c}\NormalTok{(}\FloatTok{0.2}\NormalTok{,}\FloatTok{0.3}\NormalTok{,}\FloatTok{0.5}\NormalTok{))}
\NormalTok{ [}\DecValTok{1}\NormalTok{] }\DecValTok{2} \DecValTok{3} \DecValTok{3} \DecValTok{1} \DecValTok{3} \DecValTok{3} \DecValTok{1} \DecValTok{2} \DecValTok{3} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  în acest caz: \(n=15\), \(x=[a,b,c,d]\) și \(p=[0.15,0.35,0.15,0.45]\)
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rand_sample}\NormalTok{(}\DecValTok{15}\NormalTok{,}\KeywordTok{c}\NormalTok{(}\StringTok{'a'}\NormalTok{,}\StringTok{'b'}\NormalTok{,}\StringTok{'c'}\NormalTok{,}\StringTok{'d'}\NormalTok{),}\KeywordTok{c}\NormalTok{(}\FloatTok{0.15}\NormalTok{,}\FloatTok{0.35}\NormalTok{,}\FloatTok{0.15}\NormalTok{,}\FloatTok{0.45}\NormalTok{))}
\NormalTok{ [}\DecValTok{1}\NormalTok{] }\StringTok{"b"} \StringTok{"d"} \StringTok{"d"} \StringTok{"d"} \StringTok{"a"} \StringTok{"b"} \StringTok{"d"} \StringTok{"a"} \StringTok{"d"} \StringTok{"c"} \StringTok{"d"} \StringTok{"d"} \StringTok{"b"} \StringTok{"b"} \StringTok{"d"}
\end{Highlighting}
\end{Shaded}

O funcție un pic mai generală este:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{GenerateDiscrete =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{n =} \DecValTok{1}\NormalTok{, x, p, }\DataTypeTok{err =} \FloatTok{1e-15}\NormalTok{)\{}
  \CommentTok{# n numarul de observatii}
  \CommentTok{# x multimea de valori}
  \CommentTok{# p vectorul de probabilitati}
  
\NormalTok{  lp =}\StringTok{ }\KeywordTok{length}\NormalTok{(p)}
\NormalTok{  lx =}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
  
  \CommentTok{# verificarea conditiilor de aplicare }
  \ControlFlowTok{if}\NormalTok{(}\KeywordTok{abs}\NormalTok{(}\KeywordTok{sum}\NormalTok{(p)}\OperatorTok{-}\DecValTok{1}\NormalTok{)}\OperatorTok{>}\NormalTok{err }\OperatorTok{|}\StringTok{ }\KeywordTok{sum}\NormalTok{(p}\OperatorTok{>=}\DecValTok{0}\NormalTok{)}\OperatorTok{!=}\NormalTok{lp)\{}
    
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Suma probabilitatilor nu este egala cu 1!"}\NormalTok{)}
    
\NormalTok{  \}}\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(lx}\OperatorTok{!=}\NormalTok{lp)\{}
    
    \KeywordTok{stop}\NormalTok{(}\StringTok{"x si p trebuie sa aiba aceeasi marime!"}\NormalTok{)}
    
\NormalTok{  \}}\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{    out =}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{, n)}
    
\NormalTok{    indOrderProb =}\StringTok{ }\KeywordTok{order}\NormalTok{(p, }\DataTypeTok{decreasing =} \OtherTok{TRUE}\NormalTok{) }\CommentTok{# index}
\NormalTok{    pOrdered =}\StringTok{ }\NormalTok{p[indOrderProb] }\CommentTok{# rearanjam valorile probabilitatilor}
\NormalTok{    xOrdered =}\StringTok{ }\NormalTok{x[indOrderProb] }\CommentTok{# rearanjam valorile lui x}
    
\NormalTok{    pOrderedCS =}\StringTok{ }\KeywordTok{cumsum}\NormalTok{(pOrdered)}
    
    \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n)\{}
\NormalTok{      u =}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)}
      
\NormalTok{      k =}\StringTok{ }\KeywordTok{min}\NormalTok{(}\KeywordTok{which}\NormalTok{(u}\OperatorTok{<=}\NormalTok{pOrderedCS))}
\NormalTok{      out[i] =}\StringTok{ }\NormalTok{xOrdered[k]}
\NormalTok{    \}}
\NormalTok{  \}}
  
  \KeywordTok{return}\NormalTok{(out)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

și pentru a o putea testa să considerăm cazul repartițiilor Poisson și
Geometrică:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\tightlist
\item
  Poisson
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Poisson}
\KeywordTok{hist}\NormalTok{(}\KeywordTok{GenerateDiscrete}\NormalTok{(}\DecValTok{10000}\NormalTok{, }\DataTypeTok{x =} \DecValTok{0}\OperatorTok{:}\DecValTok{50}\NormalTok{, }
                      \DataTypeTok{p =} \KeywordTok{dpois}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{50}\NormalTok{, }\DecValTok{5}\NormalTok{)), }
     \DataTypeTok{probability =} \OtherTok{TRUE}\NormalTok{, }
     \DataTypeTok{breaks =} \KeywordTok{seq}\NormalTok{(}\OperatorTok{-}\FloatTok{0.5}\NormalTok{,}\FloatTok{49.5}\NormalTok{, }\DataTypeTok{by =} \DecValTok{1}\NormalTok{), }
     \DataTypeTok{xlim =} \KeywordTok{c}\NormalTok{(}\OperatorTok{-}\FloatTok{0.5}\NormalTok{, }\DecValTok{20}\NormalTok{),}
     \DataTypeTok{col =} \StringTok{"grey80"}\NormalTok{,}
     \DataTypeTok{main =} \StringTok{"Repartitia Poisson"}\NormalTok{,}
     \DataTypeTok{xlab =} \StringTok{"X"}\NormalTok{,}
     \DataTypeTok{ylab =} \StringTok{"Densitatea"}\NormalTok{)}

\KeywordTok{lines}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{50}\NormalTok{,}
      \KeywordTok{dpois}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{50}\NormalTok{, }\DecValTok{5}\NormalTok{), }
      \DataTypeTok{type =} \StringTok{"l"}\NormalTok{, }
      \DataTypeTok{col =} \StringTok{"brown3"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-28-1} \end{center}

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\setcounter{enumi}{1}
\tightlist
\item
  Geometrică
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Geometric}
\KeywordTok{hist}\NormalTok{(}\KeywordTok{GenerateDiscrete}\NormalTok{(}\DecValTok{10000}\NormalTok{, }\DataTypeTok{x =} \DecValTok{0}\OperatorTok{:}\DecValTok{100}\NormalTok{, }
                      \DataTypeTok{p =} \KeywordTok{dgeom}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\FloatTok{0.3}\NormalTok{)), }
     \DataTypeTok{probability =} \OtherTok{TRUE}\NormalTok{, }
     \DataTypeTok{breaks =} \KeywordTok{seq}\NormalTok{(}\OperatorTok{-}\FloatTok{0.5}\NormalTok{,}\FloatTok{99.5}\NormalTok{, }\DataTypeTok{by =} \DecValTok{1}\NormalTok{),}
     \DataTypeTok{xlim =} \KeywordTok{c}\NormalTok{(}\OperatorTok{-}\FloatTok{0.5}\NormalTok{, }\DecValTok{20}\NormalTok{),}
     \DataTypeTok{col =} \StringTok{"grey80"}\NormalTok{,}
     \DataTypeTok{main =} \StringTok{"Repartitia Geometrica"}\NormalTok{,}
     \DataTypeTok{xlab =} \StringTok{"X"}\NormalTok{,}
     \DataTypeTok{ylab =} \StringTok{"Densitatea"}\NormalTok{)}

\KeywordTok{lines}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{100}\NormalTok{,}
      \KeywordTok{dgeom}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\FloatTok{0.3}\NormalTok{), }
      \DataTypeTok{type =} \StringTok{"l"}\NormalTok{, }
      \DataTypeTok{col =} \StringTok{"brown3"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-29-1} \end{center}

\subsection{Generarea unei variabile aleatoare folosind metoda
inversă}\label{generarea-unei-variabile-aleatoare-folosind-metoda-inversa}

\begin{rmdexercise}
Scrieți un program care să folosească metoda transformării inverse
pentru a genera \(n\) observații din densitatea

\[
  f(x) = \left\{\begin{array}{ll}
        \frac{1}{x^2}, & x\geq 1\\
        0, & \text{altfel}
  \end{array}\right.
\]

Testați programul trasând o histogramă a \(10000\) de observații
aleatoare împreună cu densitatea teoretică \(f\).
\end{rmdexercise}

Primul pas este să determinăm funcția de repartiție \(F\)
corespunzătoare acestei densități. Pentru \(x<1\) avem că \(f(x)=0\)
deci \(F(x)=0\) iar pentru \(x\geq 1\) avem

\[
  F(x) = \int_{1}^{x}\frac{1}{t^2}\, dt = 1 - \frac{1}{x}.
\] Cum \(F\) este continuă putem să determinăm \(F^{-1}\) rezolvând
ecuația \(F(x)=u\). Un calcul direct conduce la
\(F^{-1}(u)=\frac{1}{1-u}\) iar conform rezultatului văzut la curs
concluzionăm că \(X = \frac{1}{1-U}\) cu \(U\sim \mathcal{U}([0,1])\).

Astfel putem simula un eșantion de talie \(n\) din populația \(f\)
construind funcția

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{GenerateSampleX =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n)\{}
\NormalTok{  u =}\StringTok{ }\KeywordTok{runif}\NormalTok{(n)}
  \KeywordTok{return}\NormalTok{(}\DecValTok{1}\OperatorTok{/}\NormalTok{(}\DecValTok{1}\OperatorTok{-}\NormalTok{u))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Pentru a testa comparăm valorile simulate cu densitatea teoretică

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# simulate}
\NormalTok{x =}\StringTok{ }\KeywordTok{GenerateSampleX}\NormalTok{(}\DecValTok{10000}\NormalTok{)}
\KeywordTok{hist}\NormalTok{(x, }\DataTypeTok{freq=}\OtherTok{FALSE}\NormalTok{, }\DataTypeTok{breaks=}\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\KeywordTok{max}\NormalTok{(x)}\OperatorTok{+}\DecValTok{1}\NormalTok{, }\FloatTok{0.1}\NormalTok{),}
     \DataTypeTok{xlim=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{10}\NormalTok{), }\DataTypeTok{ylim=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{),}
     \DataTypeTok{main=}\OtherTok{NULL}\NormalTok{, }\DataTypeTok{col=}\StringTok{"gray80"}\NormalTok{, }\DataTypeTok{border=}\StringTok{"gray20"}\NormalTok{)}

\CommentTok{# densitatea teoretica}
\NormalTok{y <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\FloatTok{0.01}\NormalTok{)}
\NormalTok{f <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(y }\OperatorTok{<=}\StringTok{ }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\OperatorTok{/}\NormalTok{y}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\KeywordTok{lines}\NormalTok{(y, f, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-32-1} \end{center}

\subsection{Generarea unei repartiții
normale}\label{generarea-unei-repartitii-normale}

\begin{rmdexercise}
Plecând cu o propunere de tip \(Exp(\lambda)\) vrem să generăm, cu
ajutorul metodei acceptării-respingerii, un eșantion din următoarea
densitate (jumătate de normală):

\[
  f(x) = \left\{\begin{array}{ll}
    \frac{2}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}, & \mbox{dacă $x\geq0$}\\
    0, & \mbox{altfel}\\           
  \end{array}\right.
\]
\end{rmdexercise}

Fie \(g\) densitatea repartiției exponențiale de parametru \(\lambda\),

\[
    g(x) = \left\{\begin{array}{ll}
        \lambda e^{-\lambda x}, & \mbox{dacă $x\geq0$}\\
        0, & \mbox{altfel}\\           
  \end{array}\right.
\]

Pentru a aplica algoritmul de acceptare-respingere trebuie să găsim
valoarea lui \(c>0\) pentru care \(f(x)\leq c g(x)\) pentru toate
valorile \(x\in \mathbb{R}\). Pentru \(x\geq0\) avem

\[
  \frac{f(x)}{g(x)}=\frac{2}{\lambda\sqrt{2\pi}}e^{-\frac{x^2}{2}+\lambda x}
\]

și cum funcția \(-\frac{x^2}{2}+\lambda x\) își atinge valoarea maximă
în punctul \(x=\lambda\) rezultă că

\[
    \frac{f(x)}{g(x)}\leq c^*, \,\,\forall x \geq0
\]

unde

\[
  c^*=\sqrt{\frac{2}{\pi\lambda^2}}e^{\lambda^2/2}.
\]

Astfel algoritmul devine:

\begin{itemize}
\item
  pentru \(n=1,2,\dots\)
\item
  generează \(X_n\sim Exp(\lambda)\)
\item
  generează \(U_n\sim\mathcal{U}[0,1]\)
\item
  dacă \(U_n\leq\exp\left(-\frac{1}{2}(X_n-\lambda)^2\right)\) atunci
\item
  intoarceți \(X_n\)
\end{itemize}

Avem funcția:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# generarea puntelor din densitatea f}

\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{return}\NormalTok{((x}\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\KeywordTok{dnorm}\NormalTok{(x,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\NormalTok{\}}

\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{ }\KeywordTok{return}\NormalTok{(}\KeywordTok{dexp}\NormalTok{(x,}\DecValTok{1}\NormalTok{)) \}}

\NormalTok{c <-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2} \OperatorTok{*}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{pi)}

\NormalTok{rhalfnormal <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{  res <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(}\DataTypeTok{length=}\NormalTok{n)}
\NormalTok{  i <-}\StringTok{ }\DecValTok{0}
  \ControlFlowTok{while}\NormalTok{ (i}\OperatorTok{<}\NormalTok{n) \{}
\NormalTok{    U <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{    X <-}\StringTok{ }\KeywordTok{rexp}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (c }\OperatorTok{*}\StringTok{ }\KeywordTok{g}\NormalTok{(X) }\OperatorTok{*}\StringTok{ }\NormalTok{U }\OperatorTok{<=}\StringTok{ }\KeywordTok{f}\NormalTok{(X)) \{}
\NormalTok{      i <-}\StringTok{ }\NormalTok{i}\OperatorTok{+}\DecValTok{1}
\NormalTok{      res[i] <-}\StringTok{ }\NormalTok{X;}
\NormalTok{    \}}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Testăm

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X <-}\StringTok{ }\KeywordTok{rhalfnormal}\NormalTok{(}\DecValTok{10000}\NormalTok{)}

\KeywordTok{hist}\NormalTok{(X, }
     \DataTypeTok{breaks=}\DecValTok{50}\NormalTok{, }
     \DataTypeTok{prob=}\OtherTok{TRUE}\NormalTok{, }
     \DataTypeTok{ylim=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{),}
     \DataTypeTok{main=}\OtherTok{NULL}\NormalTok{, }
     \DataTypeTok{col=}\StringTok{"gray80"}\NormalTok{, }
     \DataTypeTok{border=}\StringTok{"gray20"}\NormalTok{)}

\KeywordTok{curve}\NormalTok{(f, }\KeywordTok{min}\NormalTok{(X), }\KeywordTok{max}\NormalTok{(X), }\DataTypeTok{n=}\DecValTok{500}\NormalTok{, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{, }\DataTypeTok{add=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-35-1} \end{center}

\begin{rmdexercise}
Modificați codul de la exercițiul precedent pentru a simula un eșantion
dintr-o normală standard.
\end{rmdexercise}

Cum \(f\) (din problema 1) este densitatea unei normale standard
\(X\sim\mathcal{N}(0,1)\) condiționată la \(X>0\) și cum densitatea
normală este simetrică față de medie (0 în acest caz) algoritmul se
modifică acceptând \(x_n\) și \(-X_n\) cu probabilitatea de \(0.5\).

Astfel avem funcția:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{return}\NormalTok{(}\KeywordTok{dnorm}\NormalTok{(x,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\NormalTok{\}}

\NormalTok{normal1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{  res <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(}\DataTypeTok{length=}\NormalTok{n)}
\NormalTok{  i <-}\StringTok{ }\DecValTok{0}
  \ControlFlowTok{while}\NormalTok{ (i}\OperatorTok{<}\NormalTok{n) \{}
\NormalTok{    U <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{    X <-}\StringTok{ }\KeywordTok{rexp}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ (c }\OperatorTok{*}\StringTok{ }\KeywordTok{g}\NormalTok{(X) }\OperatorTok{*}\StringTok{ }\NormalTok{U }\OperatorTok{<=}\StringTok{ }\KeywordTok{f}\NormalTok{(X)) \{}
\NormalTok{      i <-}\StringTok{ }\NormalTok{i}\OperatorTok{+}\DecValTok{1}
      
\NormalTok{      res[i] <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\OperatorTok{<=}\StringTok{ }\FloatTok{0.5}\NormalTok{, X, }\OperatorTok{-}\NormalTok{X);}
\NormalTok{    \}}
\NormalTok{  \}}
  \KeywordTok{return}\NormalTok{(res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

si testul

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{X <-}\StringTok{ }\KeywordTok{normal1}\NormalTok{(}\DecValTok{10000}\NormalTok{)}

\KeywordTok{hist}\NormalTok{(X, }\DataTypeTok{breaks=}\DecValTok{50}\NormalTok{, }
     \DataTypeTok{prob=}\OtherTok{TRUE}\NormalTok{, }
     \DataTypeTok{main=}\OtherTok{NULL}\NormalTok{, }
     \DataTypeTok{col=}\StringTok{"gray80"}\NormalTok{, }\DataTypeTok{border=}\StringTok{"gray20"}\NormalTok{)}

\KeywordTok{curve}\NormalTok{(f2, }\KeywordTok{min}\NormalTok{(X), }\KeywordTok{max}\NormalTok{(X), }\DataTypeTok{n=}\DecValTok{500}\NormalTok{,}\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{lty =} \DecValTok{2}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{2}\NormalTok{, }\DataTypeTok{add=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-38-1} \end{center}

\subsection{Simularea unei uniforme pe
disc}\label{simularea-unei-uniforme-pe-disc}

\begin{rmdexercise}
Considerăm pătratul \(C = [0,L]^2\) și discul \(D\) de centru
\((\frac{L}{2},\frac{L}{2})\) și rază \(\frac{L}{2}\). Considerăm șirul
de v.a. \(\left(Y_n\right)_{n\geq1}\) pe \(\mathbb{R}^2\) i.i.d.
repartizate uniform pe pătratul \(C\).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Aproximați valoarea lui \(\pi\) prin ajutorul numărului de puncte
  \(Y_n\) care cad în interiorul discului \(D\) (Metoda respingerii)
\item
  Simulați \(n\) puncte uniforme pe disc.
\end{enumerate}
\end{rmdexercise}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Definim v.a. \(X_n=\mathbf{1}_{\{Y_n\in D\}}\), \(n\geq1\), care
  formează un șir de v.a. i.i.d. de lege
  \(\mathcal{B}(\mathbb{P}(Y_n\in D))\), deoarece
  \(\left(Y_n\right)_{n\geq1}\) este un șir de v.a. i.i.d. repartizate
  uniform pe \(C\), \(\mathcal{U}(C)\). Din \emph{Legea Numerelor Mari}
  avem că
\end{enumerate}

\[
  \displaystyle\frac{1}{n}\sum_{i=1}^{n}X_{i} \overset{a.s.}{\to} \mathbb{E}[X_1] = \mathbb{P}(Y_1\in D),
\]

prin urmare trebuie să calculăm probabilitatea \(\mathbb{P}(Y_1\in D)\).
Știm că densitatea v.a. \(Y_1\) este dată de
\(f_{Y_1}(x,y)=\frac{1}{\mathcal{A}(C)}\mathbf{1}_{C}(x,y)\) de unde

\[
\begin{aligned}
  \mathbb{P}(Y_1\in D) &= \iint_{D}f_{Y_1}(x,y)\,dxdy = \iint \mathbf{1}_{D}(x,y)\mathbf{1}_{C}(x,y)\,dxdy\\
                       &= \frac{1}{\mathcal{A}(C)}\iint \mathbf{1}_{D}(x,y)\,dxdy = \frac{\mathcal{A}(D)}{\mathcal{A}(C)} = \frac{\pi \frac{L^2}{4}}{L^2} = \frac{\pi}{4}.
\end{aligned}
\]

Astfel, putem estima valoarea lui \(\pi\) prin
\(\displaystyle\frac{4}{n}\sum_{i=1}^{n}X_{i}\) pentru valori mari ale
lui \(n\).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Estimam valoarea lui pi}

\NormalTok{L =}\StringTok{ }\DecValTok{3} \CommentTok{# lungimea laturii patratului }
\NormalTok{R =}\StringTok{ }\NormalTok{L}\OperatorTok{/}\DecValTok{2} \CommentTok{# raza cercului inscris}

\NormalTok{n =}\StringTok{ }\DecValTok{2000} \CommentTok{# numarul de puncte din patratul C}
\CommentTok{# generam puncte uniforme in C}
\NormalTok{x =}\StringTok{ }\NormalTok{L}\OperatorTok{*}\KeywordTok{runif}\NormalTok{(n)}
\NormalTok{y =}\StringTok{ }\NormalTok{L}\OperatorTok{*}\KeywordTok{runif}\NormalTok{(n)}

\CommentTok{# metoda respingerii (rejectiei)}
\NormalTok{l =}\StringTok{ }\NormalTok{(x}\OperatorTok{-}\NormalTok{R)}\OperatorTok{^}\DecValTok{2}\OperatorTok{+}\NormalTok{(y}\OperatorTok{-}\NormalTok{R)}\OperatorTok{^}\DecValTok{2} \CommentTok{# distanta dintre centrul cercului si punct}
\NormalTok{ind =}\StringTok{ }\NormalTok{l}\OperatorTok{<=}\NormalTok{(R)}\OperatorTok{^}\DecValTok{2} \CommentTok{# indicii pentru care distanta este mai mica sau egala cu R}

\NormalTok{xc =}\StringTok{ }\NormalTok{x[ind] }\CommentTok{# coordonatele punctelor din interiorul cercului  }
\NormalTok{yc =}\StringTok{ }\NormalTok{y[ind] }

\NormalTok{estimate_pi =}\StringTok{ }\DecValTok{4}\OperatorTok{*}\KeywordTok{sum}\NormalTok{(ind)}\OperatorTok{/}\NormalTok{n }\CommentTok{# estimarea lui pi}
\NormalTok{err =}\StringTok{ }\KeywordTok{abs}\NormalTok{(estimate_pi}\OperatorTok{-}\NormalTok{pi) }\CommentTok{# eroarea absoluta}
\end{Highlighting}
\end{Shaded}

Aplicând acest procedeu obținem că valoarea estimată a lui \(\pi\) prin
generarea a \(n=\) 2000 puncte este 3.16 iar eroarea absoluta este
0.01841.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Una dintre metodele prin care putem simula puncte uniform repartizate
  pe suprafața discului \(D\) este \emph{Metoda respingerii}. Această
  metodă consistă în generarea de v.a. \(Y_n\) repartizate uniform pe
  suprafața pătratului \(C\), urmând ca apoi să testăm dacă \(Y_n\)
  aparține discului \(D\) (deoarece \(D\subset C\)). Dacă da, atunci le
  păstrăm dacă nu atunci mai generăm. Următoarea figură ilustrează
  această metodă:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# figura }
\NormalTok{theta =}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\OperatorTok{*}\NormalTok{pi}\OperatorTok{+}\DecValTok{1}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.1}\NormalTok{)}
\NormalTok{xd =}\StringTok{ }\NormalTok{R}\OperatorTok{+}\NormalTok{R}\OperatorTok{*}\KeywordTok{cos}\NormalTok{(theta)}
\NormalTok{yd =}\StringTok{ }\NormalTok{R}\OperatorTok{+}\NormalTok{R}\OperatorTok{*}\KeywordTok{sin}\NormalTok{(theta)}

\KeywordTok{plot}\NormalTok{(x, y, }
     \DataTypeTok{col =} \StringTok{"grey80"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{,}
     \DataTypeTok{asp =} \DecValTok{1}\NormalTok{, }
     \DataTypeTok{xlim =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{3}\NormalTok{), }\DataTypeTok{ylim =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{3}\NormalTok{),}
     \DataTypeTok{bty =} \StringTok{"n"}\NormalTok{)}

\KeywordTok{points}\NormalTok{(xc, yc, }\DataTypeTok{col =} \StringTok{"brown3"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{)}
\KeywordTok{lines}\NormalTok{(xd, yd, }\DataTypeTok{col =} \StringTok{"royalblue"}\NormalTok{, }\DataTypeTok{lwd =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-41-1} \end{center}

Vom da mai jos o altă metodă de simulare a punctelor distribuite uniform
pe discul \(D\) de rază \(L\). O primă idee ar fi să generăm cuplul de
v.a. \((X_1,Y_1)\) așa încât \(X_1,Y_1\sim\mathcal{U}([0,L])\) și ele să
fie independente (ceea ce nu este adevărat în realitate). Vom vedea
(printr-o ilustrație grafică) că această abordare este greșită (punctele
sunt concentrate în centrul cercului).

O altă abordare este următoarea. Căutăm să simulăm un cuplu de v.a.
\((X,Y)\) care este uniform distribuit pe suprafața discului \(D\),
i.e.~densitatea cuplului este dată de
\(f_{(X,Y)}(x,y)=\frac{1}{\pi L^2}\mathbf{1}_{D}(x,y)\). Considerăm
schimbarea de variablile în coordonate polare: \(x=r\cos(\theta)\) și
\(y=r\sin(\theta)\). Obiectivul este de a găsi densitatea variabilelor
\(R\) și \(\Theta\).

Fie \(g(x,y)=\left(\sqrt{x^2+y^2},\arctan(y/x)\right)=(r,\theta)\),
transformarea pentru care avem \((R,\Theta)=g(X,Y)\). Știm că inversa
acestei transformări este
\(g^{-1}(r,\theta)=(r\cos(\theta),r\sin(\theta))\), prin urmare

\[
\begin{aligned}
  f_{(R,\Theta)}(r,\theta) &= f_{(X,Y)}\left(g^{-1}(r,\theta)\right)|\det(J_{g^{-1}}(r,\theta))|\\
                &= \frac{1}{\pi L^2}\mathbf{1}_{D}(r\cos(\theta),r\sin(\theta))\left|\begin{array}{cc}
                    \cos(\theta) & \sin(\theta)\\
                    r\sin(\theta) & -r\cos(\theta)
                \end{array}\right|\\
                &= \frac{1}{\pi L^2} \mathbf{1}_{[0,L]}(r)\mathbf{1}_{[0,2\pi]}(\theta)r.
\end{aligned}
\]

Observăm că densitatea (marginală) v.a. \(\Theta\) este

\[
\begin{aligned}
  f_{\Theta}(\theta) &= \int f_{(R,\Theta)}(r,\theta)\,dr = \mathbf{1}_{[0,2\pi]}(\theta)\int \frac{r}{\pi L^2} \mathbf{1}_{[0,L]}(r)\,d\theta\\
                     &= \frac{1}{\pi L^2} \mathbf{1}_{[0,2\pi]}(\theta) \frac{L^2}{2} = \frac{1}{2\pi} \mathbf{1}_{[0,2\pi]}(\theta),
\end{aligned}
\]

iar densitatea v.a. \(R\) este

\[
\begin{aligned}
  f_{R}(r) &= \int f_{(R,\Theta)}(r,\theta)\,d\theta = \frac{r}{\pi L^2} \mathbf{1}_{[0,L]}(r)\int_{0}^{2\pi}\,d\theta\\
                     &= \frac{r}{\pi L^2} \mathbf{1}_{[0,L]}(r)2\pi = \frac{2r}{L^2} \mathbf{1}_{[0,L]}(r).
\end{aligned}
\]

Din expresiile de mai sus putem observa că \(\Theta\) este o v.a.
repartizată uniform pe \([0,2\pi]\) și putem verifica ușor că legea v.a.
\(R\) este aceeași cu cea a v.a. \(L\sqrt{U}\) unde
\(U\sim\mathcal{U}([0,1])\).

Astfel pentru simularea unui punct \((X,Y)\) uniform pe \(D\) este
suficient să simulăm o v.a. \(\Theta\) uniform pe \([0,2\pi]\) și o v.a.
\(U\) uniformă pe \([0,1]\) și să luăm \(X=L\sqrt{U}\cos(\Theta)\) și
\(Y=L\sqrt{U}\sin(\Theta)\).

Următorul cod ne ilustrează cele două proceduri prezentate:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rm}\NormalTok{(}\DataTypeTok{list=}\KeywordTok{ls}\NormalTok{())}

\NormalTok{n =}\StringTok{ }\DecValTok{2000}\NormalTok{;}\CommentTok{# numarul de puncte}

\NormalTok{R =}\StringTok{ }\DecValTok{10}\NormalTok{;}\CommentTok{# raza cercului }

\NormalTok{theta =}\StringTok{ }\DecValTok{2}\OperatorTok{*}\NormalTok{pi}\OperatorTok{*}\KeywordTok{runif}\NormalTok{(n);}\CommentTok{# theta este uniforma pe [0,2*pi]}

\CommentTok{# versiunea gresita - r este uniforme pe [0,R]}
\NormalTok{r1 =}\StringTok{ }\NormalTok{R}\OperatorTok{*}\KeywordTok{runif}\NormalTok{(n);}

\NormalTok{x1 =}\StringTok{ }\NormalTok{r1}\OperatorTok{*}\KeywordTok{cos}\NormalTok{(theta);}\CommentTok{# coordonate polare}
\NormalTok{y1 =}\StringTok{ }\NormalTok{r1}\OperatorTok{*}\KeywordTok{sin}\NormalTok{(theta);}

\CommentTok{# versiunea corecta}
\NormalTok{r2 =}\StringTok{ }\NormalTok{R}\OperatorTok{*}\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{runif}\NormalTok{(n));}

\NormalTok{x2 =}\StringTok{ }\NormalTok{r2}\OperatorTok{*}\KeywordTok{cos}\NormalTok{(theta);}\CommentTok{# coordonate polare}
\NormalTok{y2 =}\StringTok{ }\NormalTok{r2}\OperatorTok{*}\KeywordTok{sin}\NormalTok{(theta);}

\CommentTok{# schimbarea de variabila in coordonate polare: cercul}
\NormalTok{theta2 =}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{2}\OperatorTok{*}\NormalTok{pi}\OperatorTok{+}\DecValTok{1}\NormalTok{,}\DataTypeTok{by=}\FloatTok{0.1}\NormalTok{) }
\NormalTok{xc =}\StringTok{ }\NormalTok{R}\OperatorTok{*}\KeywordTok{cos}\NormalTok{(theta2);}
\NormalTok{yc =}\StringTok{ }\NormalTok{R}\OperatorTok{*}\KeywordTok{sin}\NormalTok{(theta2);}

\CommentTok{# graficul}

\KeywordTok{par}\NormalTok{(}\DataTypeTok{mfrow =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{))}

\KeywordTok{plot}\NormalTok{(x1, y1,}
     \DataTypeTok{ylim =} \KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{11}\NormalTok{, }\DecValTok{11}\NormalTok{),}
     \DataTypeTok{col =} \StringTok{"brown3"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{,}
     \DataTypeTok{main =} \StringTok{"Versiunea gresita"}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"x"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"y"}\NormalTok{, }\DataTypeTok{asp =} \DecValTok{1}\NormalTok{, }\DataTypeTok{bty =} \StringTok{"n"}\NormalTok{)}
\KeywordTok{lines}\NormalTok{(xc, yc, }\DataTypeTok{lwd =} \DecValTok{3}\NormalTok{, }\DataTypeTok{col =} \StringTok{"royalblue"}\NormalTok{)}

\KeywordTok{plot}\NormalTok{(x2, y2,}
     \DataTypeTok{ylim =} \KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{11}\NormalTok{, }\DecValTok{11}\NormalTok{),}
     \DataTypeTok{col =} \StringTok{"brown3"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{,}
     \DataTypeTok{main =} \StringTok{"Versiunea corecta"}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"x"}\NormalTok{, }\DataTypeTok{ylab =} \StringTok{"y"}\NormalTok{, }\DataTypeTok{asp =} \DecValTok{1}\NormalTok{, }\DataTypeTok{bty =} \StringTok{"n"}\NormalTok{)}
\KeywordTok{lines}\NormalTok{(xc, yc, }\DataTypeTok{lwd =} \DecValTok{3}\NormalTok{, }\DataTypeTok{col =} \StringTok{"royalblue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics{Lab_3_files/figure-latex/unnamed-chunk-42-1} \end{center}


\end{document}
